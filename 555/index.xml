<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>codeforces on wish you like</title>
    <link>https://santorin2k.github.io/555/</link>
    <description>Recent content in codeforces on wish you like</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 31 Oct 2017 22:27:21 -0500</lastBuildDate><atom:link href="https://santorin2k.github.io/555/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>（CF1574X）Codeforces Round #731 (Div. 3)</title>
      <link>https://santorin2k.github.io/555/blogs/</link>
      <pubDate>Tue, 31 Oct 2017 22:27:21 -0500</pubDate>
      
      <guid>https://santorin2k.github.io/555/blogs/</guid>
      <description>（CF1574X）Codeforces Round #731 (Div. 3) A.Shortest Path with Obstacle 题意：坐标系中有三个点A,B,F，问A到达B且不经过F的最短路径。
直接分两种情况，如果ABF在一条直线上则需要绕道，即A到B的直线距离加上2即可，若不在一条直线，则直接输出A到B的折线距离。
#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; int main() { int t; cin&amp;gt;&amp;gt;t; while(t--) { vector&amp;lt;int&amp;gt;a(2); vector&amp;lt;int&amp;gt;b(2); vector&amp;lt;int&amp;gt;c(2); cin&amp;gt;&amp;gt;a[0]&amp;gt;&amp;gt;a[1]; cin&amp;gt;&amp;gt;b[0]&amp;gt;&amp;gt;b[1]; cin&amp;gt;&amp;gt;f[0]&amp;gt;&amp;gt;f[1]; int ans=abs(a[0]-b[0])+abs(a[1]-b[1]); if((a[0]==b[0]&amp;amp;&amp;amp;a[0]==f[0]&amp;amp;&amp;amp;min(a[1],b[1])&amp;lt;f[1]&amp;amp;&amp;amp;f[1]&amp;lt;max(a[1],b[1])) ||(a[1]==b[1]&amp;amp;&amp;amp;a[1]==f[1]&amp;amp;&amp;amp;min(a[0],b[0])&amp;lt;f[0]&amp;amp;&amp;amp;f[0]&amp;lt;max(a[0],b[0]))) ans+=2; cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;&amp;#39;\n&amp;#39;; } } B.Alphabetical Strings 题意：判断一个字符串是否可以按字母表的顺序依次排列出来，比如ihfcbadeg，首先给出a，然后b可以选择放在最左端或最右端，接着再看c能不能放在最左端或最右端，依此类推。
故可以发现满足条件的字符串，必然满足下面两点： a左边必然严格下降，a右边必然严格上升。 出现的字母个数为n，且为字母表中第一个到第n个字符。
#include&amp;lt;bits/stdc++.h&amp;gt;using namespace std; string s; int main() { int t; cin&amp;gt;&amp;gt;t; while(t--) { int index,flag=0; cin&amp;gt;&amp;gt;s; for(int i=0;i&amp;lt;s.size();i++) { if(s[i]==&amp;#39;a&amp;#39;)index=i; if(s.find(char(&amp;#39;a&amp;#39;+i))!=string::npos) continue; else { flag=1; break; } } if(!</description>
    </item>
    
  </channel>
</rss>
